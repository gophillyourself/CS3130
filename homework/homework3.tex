\documentclass[12pt,largemargins]{homework}

  \newcommand{\hwname}{Phillip Janowski}
  \newcommand{\hwemail}{pajmc2@mail.umsl.edu}
  \newcommand{\hwtype}{Homework}
  \newcommand{\hwnum}{3}
  \newcommand{\hwlecture}{E}
  \newcommand{\hwsection}{01}
  \newcommand{\hwclass}{CS3130}

\usepackage{graphicx}
\usepackage{makecell}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{forest}

\begin{document}
\maketitle
\question
6.1-1\\
What are the minimum and maximum numbers of elements in a heap of height $ h $\\
Minimum will be a heap with only one node in its bottom level\\
\begin{center}
$ 2^0 + 2^1 + 2^2 + ... + 2^{h-1} + 1 $\\
$ \frac{2^{h} - 1 }{2 - 1} + 1 = 2^h$\\
\end{center}
Maximum is a heap with the bottom node full\\
\begin{center}
$ 2^0 + 2^1 + 2^2 + ... + 2^{h}$\\
$ \frac{2^{h+1} - 1}{2 - 1}  = 2^{h + 1} -1$\\
\end{center}
\question
Using Figure 6.2 (p. 155) as a model, illustrate the operation of the function MAX-HEAPIFY (A, 3) on the array A=<30, 25, 5, 18, 9, 12, 6, 7, 13, 8, 1, 4, 11, 2>\\
Here $ i = 3 $ and $ A[3]=5 $
\begin{center}
	\begin{forest}
		[30
			[25
				[18
					[7]
					[13]
				]
				[9
					[8]
					[1]
				]
			]
			[5
				[12
					[4]
					[11]
				]
					[6
					[2]
				]
			]
		]
	\end{forest}\\
	\begin{forest}
		[30
			[25
				[18
					[7]
					[13]
				]
				[9
					[8]
					[1]
				]
			]
			[12
				[5
					[4]
					[11]
				]
				[6
					[2]
				]
			]
		]
	\end{forest}\\
	\begin{forest}
		[30
			[25
				[18
					[7]
					[13]
				]
				[9
					[8]
					[1]
				]
			]
			[12
				[11
					[4]
					[5]
				]
				[6
					[2]
				]
			]
		]
	\end{forest}
\end{center}
\question
Given a sequence: <C, O, R, N, F, L, A, K, E, S >. Build a heap using a bottom-up approach (see the function BUILD-MAX-HEAP, p.157); show graphically each step of this procedure!\\
\begin{forest}
	[C
		[O
			[N
				[K]
				[E]
			]
			[F
				[S]
			]
		]
		[R
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[O
			[N
				[K]
				[E]
			]
			[F
				[S]
			]
		]
		[C
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[O
			[N
				[K]
				[E]
			]
			[F
				[S]
			]
		]
		[L
			[C]
			[A]
		]
	]
\end{forest}\\
\begin{forest}
	[R
		[O
			[N
				[K]
				[E]
			]
			[S
				[F]
			]
		]
		[L
			[C]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[S
			[N
				[K]
				[E]
			]
			[O
				[F]
			]
		]
		[L
			[C]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[S
		[R
			[N
				[K]
				[E]
			]
			[O
				[F]
			]
		]
		[L
			[C]
			[A]
		]
	]
\end{forest}
\question
Given a sequence: < C, O, R, N, F, L, A, K, E, S >. Build a heap using a top-down approach (see the handout posted on MyGateway site); show graphically each step of this procedure!\\
\begin{center}
\begin{forest}
	[C]
\end{forest}
\begin{forest}
	[C
		[O]
	]
\end{forest}
\begin{forest}
		[O
			[C]
		]
\end{forest}
\begin{forest}
	[O
		[C]
		[R]
	]
\end{forest}
\begin{forest}
	[R
		[C]
		[O]
	]
\end{forest}
\begin{forest}
	[R
		[C
			[N]
		]
		[O]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[C]
		]
		[O]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[C]
			[F]
		]
		[O]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[C]
			[F]
		]
		[O
			[L]
		]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[C]
			[F]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[C
				[K]
			]
			[F]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[K
				[C]
			]
			[F]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[K
				[C]
				[E]
			]
			[F]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[K
				[C]
				[E]
			]
			[F
				[S]
			]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[N
			[K
				[C]
				[E]
			]
			[S
				[F]
			]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[R
		[S
			[K
				[C]
				[E]
			]
			[N
				[F]
			]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\begin{forest}
	[S
		[R
			[K
				[C]
				[E]
			]
			[N
				[F]
			]
		]
		[O
			[L]
			[A]
		]
	]
\end{forest}
\end{center}
\question
6.2-3\\
What is the effect of calling Max-Heapify(A,i) when the element A[i] is larger than its children?\\

No effect. The three if conditions,
\begin{center}
if $ l \leq A.heap - size $ and $ A[l] >A[i] $,\\
if $ r \leq A.heap - size $ and $ A[r] > A[largest] $\\
if $ largest \neq i $ \\
\end{center}
all fail and nothing changes.\\

\question
6.2-4\\
What is the effect of calling Max-Heapify(A, i) for $ i > A.heap-size/2$?\\

If $ i > A.heap-size/2 $, then node $ i $ is either in the lowest or second lowest level of the tree and does not have any children. Whene LEFT($ i $) and RIGHT($ i $) are called the array index that gets called will be out of bounds.\\

\question

6.4-1\\
Using Figure 6.4 as a model, illustrate the operation of HEAPSORT on the array
A <5, 13, 2, 25, 7, 17, 20, 8, 4>\\
\begin{center}
\begin{forest}
	[5
		[13
			[25
				[8]
				[4]
			]
			[7]
		]
		[2
			[17]
			[20]
		]
	]
\end{forest}
\begin{forest}
	[13
		[5
			[25
				[8]
				[4]
			]
			[7]
		]
		[2
			[17]
			[20]
		]
	]
\end{forest}
\begin{forest}
	[13
		[25
			[5
				[8]
				[4]
			]
			[7]
		]
		[2
			[17]
			[20]
		]
	]
\end{forest}
\begin{forest}
	[25
		[13
			[5
				[8]
				[4]
			]
			[7]
		]
		[2
			[17]
			[20]
		]
	]
\end{forest}
\begin{forest}
	[25
		[13
			[8
				[5]
				[4]
			]
			[7]
		]
		[2
			[17]
			[20]
		]
	]
\end{forest}
\begin{forest}
	[25
		[13
			[8
				[5]
				[4]
			]
			[7]
		]
		[20
			[17]
			[2]
		]
	]
\end{forest}
\begin{forest}
	[4
		[13
			[8
				[5]
				[|25|]
			]
			[7]
		]
		[20
			[17]
			[2]
		]
	]
\end{forest}
\begin{forest}
	[20
		[13
			[8
				[5]
				[|25|]
			]
			[7]
		]
		[17
			[4]
			[2]
		]
	]
\end{forest}
\begin{forest}
	[5
		[13
			[8
				[|20|]
				[|25|]
			]
			[7]
		]
		[17
			[4]
			[2]
		]
	]
\end{forest}
\begin{forest}
	[17
		[13
			[8
				[|20|]
				[|25|]
			]
			[7]
		]
		[5
			[4]
			[2]
		]
	]
\end{forest}
\begin{forest}
	[2
		[13
			[8
				[|20|]
				[|25|]
			]
			[7]
		]
		[5
			[4]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[13
		[8
			[2
				[|20|]
				[|25|]
			]
			[7]
		]
		[5
			[4]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[4
		[8
			[2
				[|20|]
				[|25|]
			]
			[7]
		]
		[5
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[8
		[7
			[2
				[|20|]
				[|25|]
			]
			[4]
		]
		[5
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[4
		[7
			[2
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[5
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[7
		[4
			[2
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[5
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[2
		[4
			[|7|
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[5
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[5
		[4
			[|7|
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[2
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[2
		[4
			[|7|
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[|5|
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[4
		[2
			[|7|
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[|5|
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[2
		[|4|
			[|7|
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[|5|
			[|13|]
			[|17|]
		]
	]
\end{forest}
\begin{forest}
	[|2|
		[|4|
			[|7|
				[|20|]
				[|25|]
			]
			[|8|]
		]
		[|5|
			[|13|]
			[|17|]
		]
	]
\end{forest}\\
Sorted A = <2, 4, 5, 7, 8, 13, 17, 20, 25>\\
\end{center}
\question
You are given a collection of n bolts of different diameters and n corresponding nuts. You are allowed only to try a nut and a bolt together, from which you can determine whether the nut is larger than the bolt, smaller than the bolt or matches the bolt exactly. However, there is no way to compare two nuts together or two bolts together. The problem is to match each bolt to its nut. Design an algorithm to solve this problem that will be similar to a quicksort (use the idea of partitioning).\\ 
Select a bolt and test every nut to find its match while also partitioning the nuts into a set of nuts that is too large and another for nuts that are too small. When the matching nut is found use that nut to partition the other bolts.\\
\end{document}

